# Как надо и как нет

## Основные типы

### `Number`, `String`, `Boolean`, и `Object`

Никогда _не используйте_ типы `Number`, `String`, `Boolean` или `Object`.
Эти типы ссылаются на непримитивные упакованные типы, которые почти никогда не используются в JavaScript-коде.

```ts
/* НЕПРАВИЛЬНО */
function reverse(s: String): String
```

_Используйте_ типы `number`, `string` и `boolean`.

```ts
/* ПРАВИЛЬНО */
function reverse(s: string): string
```

Если вам хочется применить тип `Object`, используйте вместо него `any`.
На данный момент в TypeScript нет способа указать, что объект должен быть "непримитивным".

### Обобщения

Никогда _не создавайте_ обобщенный тип, который не использует типовый параметр.
Больше информации на странице [часто задаваемых вопросов](https://github.com/Microsoft/TypeScript/wiki/FAQ#why-doesnt-type-inference-work-on-this-interface-interface-foot---).

## Типы функций обратного вызова

### Типы возвращаемых значений функций обратного вызова

_Не используйте_ `any` в качестве типа возвращаемого значения для функций обратного вызова, чье возвращаемое значение игнорируется:

```ts
/* НЕПРАВИЛЬНО */
function fn(x: () => any) {
  x()
}
```

_Используйте_ тип `void` в подобных случаях:

```ts
/* ПРАВИЛЬНО */
function fn(x: () => void) {
  x()
}
```

_Почему_: использование `void` более безопасно, поскольку защищает от случайного использования возвращаемого значения `x` без проверки типов:

```ts
function fn(x: () => void) {
  var k = x() // упс! планировалось написать что-то другое
  k.doSomething() // ошибка, но все было бы нормально, если бы тип возвращаемого значения был 'any'
}
```

### Необязательные параметры в функциях обратного вызова

_Не используйте_ необязательные параметры в функциях обратного вызова, кроме случаев, когда они необходимы:

```ts
/* НЕПРАВИЛЬНО */
interface Fetcher {
  getObject(
    done: (data: any, elapsedTime?: number) => void
  ): void
}
```

Это имеет следующее значение: функция обратного вызова `done` может быть вызвана либо с одним, либо с двумя аргументами.
Разработчик, вероятно, намеревался выразить то, что функция обратного вызова может не обращать внимания на параметр `elapsedTime`, однако для этого не нужно делать параметр необязательным — передача функции обратного вызова, которая принимает меньшее число аргументов, всегда допускается.

Всегда _используйте_ обязательные параметры для функции обратного вызова:

```ts
/* ПРАВИЛЬНО */
interface Fetcher {
  getObject(
    done: (data: any, elapsedTime: number) => void
  ): void
}
```

### Перегрузки и функции обратного вызова

_Не создавайте_ отдельных перегрузок, различающихся только числом аргументов у функции обратного вызова:

```ts
/* НЕПРАВИЛЬНО */
declare function beforeAll(
  action: () => void,
  timeout?: number
): void
declare function beforeAll(
  action: (done: DoneFn) => void,
  timeout?: number
): void
```

_Создавайте_ одну общую перегрузку с максимальным числом аргументов:

```ts
/* ПРАВИЛЬНО */
declare function beforeAll(
  action: (done: DoneFn) => void,
  timeout?: number
): void
```

_Почему_: функция с меньшим числом параметров всегда допустима, поэтому необходимости в более короткой перегрузке нет.
Добавление в начало варианта с более короткой перегрузкой приводит к тому, что неподходящие по типу функции будут допускаться, поскольку подходят к первой перегрузке.

## Перегрузки функций

### Упорядочивание

_Не помещайте_ более общие перегрузки перед более специфичными:

```ts
/* НЕПРАВИЛЬНО */
declare function fn(x: any): any
declare function fn(x: HTMLElement): number
declare function fn(x: HTMLDivElement): string

var myElem: HTMLDivElement
var x = fn(myElem) // x: any, wat?
```

_Сортируйте_ перегрузки так, чтобы более общие находились после более специфичных:

```ts
/* ПРАВИЛЬНО */
declare function fn(x: HTMLDivElement): string
declare function fn(x: HTMLElement): number
declare function fn(x: any): any

var myElem: HTMLDivElement
var x = fn(myElem) // x: string, :)
```

_Почему_: при разрешении вызовов функции TypeScript выбирает _первую подходящую перегрузку_.
Если первая перегрузка является более общей, чем последующие, то последующие перегрузки оказываются скрыты и не могут быть вызваны.

### Используйте необязательные параметры

_Не создавайте_ несколько перегрузок, отличающихся только конечными аргументами:

```ts
/* НЕПРАВИЛЬНО */
interface Moment {
  diff(b: MomentComparable): number
  diff(b: MomentComparable, unitOfTime: string): number
  diff(
    b: MomentComparable,
    unitOfTime: string,
    round: boolean
  ): number
}
```

_Используйте_ необязательные параметры, если это возможно:

```ts
/* ПРАВИЛЬНО */
interface Moment {
  diff(
    b: MomentComparable,
    unitOfTime?: string,
    round?: boolean
  ): number
}
```

Обратите внимание, что подобное "схлопывание" возможно только если у всех перегрузок один и тот же тип возвращаемого значения.

_Почему_: Это важно по двум причинам.

TypeScript определяет совместимость сигнатур, определяя, может ли какая-либо сигнатура цели вызвана с аргументами исходной сигнатуры, причем _лишние аргументы допускаются_.
Следующий код, например, позволяет обнаружить ошибку только в том случае, если сигнатура правильно записана с использованием необязательных параметров:

```ts
function fn(x: (a: string, b: number, c: number) => void) {}
var x: Moment
// Если записано с перегрузками, все нормально — использована первая перегрузка
// Если записано с необязательными параметрами, обнаруживается ошибка
fn(x.diff)
```

Вторая причина — применение к коду, использующему библиотеку, "строгой проверки на `null`".
Поскольку пропущенные параметры для JavaScript выглядят как `undefined`, то, как правило, функции с необязательными параметрами можно явно передать `undefined`.
Следующий код, например, должен компилироваться при строгой проверке на `null`:

```ts
var x: Moment
// Если записано с перегрузками, то несправедливая ошибка, так как передается 'undefined' вместо 'string'
// Если записано с необязательными параметрами, то все нормально
x.diff(something, someOtherThing ? undefined : 'hour')
```

### Используйте объединения

_Не создавайте_ перегрузок, которые отличаются только типом одного аргумента:

```ts
/* НЕПРАВИЛЬНО */
interface Moment {
  utcOffset(): number
  utcOffset(b: number): Moment
  utcOffset(b: string): Moment
}
```

_Используйте_ объединения, если это возможно:

```ts
/* ПРАВИЛЬНО */
interface Moment {
  utcOffset(): number
  utcOffset(b: number | string): Moment
}
```

Обратите внимание, что параметр `b` не сделан необязательным, так как типы возвращаемых значений различаются.

_Почему_: Это важно для тех, кто передает значения "сквозь" функцию:

```ts
function fn(x: string): void
function fn(x: number): void
function fn(x: number | string) {
  // Если записано с отдельными перегрузками, то несправедливая ошибка
  // Если записано с объединениями, то все нормально
  return moment().utcOffset(x)
}
```

## Ссылки

- [Как надо и как нет](http://typescript-lang.ru/docs/declaration%20files/Do's%20and%20Don'ts.html)
